\input texinfo	@c -*-texinfo
@c %**start of header
@setfilename vrtater.info
@c automake vars: these will later be in version.texi and maintained by automake
@set VERSION 0.3.62 pre-alpha
@set UPDATED September 2013
@c other vars
@set DEVELOP @uref{http://savannah.nongnu.org/projects/vrtater/}
@c end vars
@settitle vrtater @value{VERSION}
@c %**end of header
@copying
This manual is for vrtater (version @value{VERSION}, @value{UPDATED}),
GNU free software, supporting peer to peers 'virtual' 'reality'.

Copyright (C) 2013 J. A. Green

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections.  A copy of the license is included in the section
entitled ``GNU Free Documentation License''.
@end quotation
@end copying

@dircategory Texinfo documantation system
@direntry
* vrtater: (vrtater)Invoking vrtater.
* vrtater: (vrtater)Installing vrtater.
* vrtater: (vrtater)Vector calls.
* vrtater: (vrtater)Hmap Selection Buffer.
* vrtater: (vrtater)Hmap Transforms.
@end direntry

@titlepage
@title vrtater, GNU GPL Peer to Peers VR Manual
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Jimmy Green (@email{green8@sdf-eu.org})
@page
@vskip 0pt plus lfilll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top vrtater Peer to Peers VR

here is the software i couldent find,,, the software u might be looking for...

vrtater

vrtater is GNU free software, and as such, the freedom to share fully in it's
current and future benefits is preserved for anyone who uses or adds to it.
With current supporting libraries heretofore mentioned, it provides a route
towards a realized peer to peers 'virtual' 'reality' enviornment, where people
running vrtater nodes may determine the dialog and the virtual worlds that
they create and then interact through.  Nodes are always peers, providing all
chosen GNU free software vrtater features.

For IO and feedback, vrtater is written to be generic and inclusive for any GNU
or GNU 'freindly' libraries mandated.  Currently, interfacing through
@file{X.h} (see: @uref{http://www.x.org/}) is being provided.  Provided also is
the rendering of vobs supported by @file{gl.h} and @file{glx.h} (see:
@uref{http://mesa3d.org/}).

Written in C, and still in pre-alpha state, vrtater already produces much of the
required mechanism for interacting, through 'virtual objects'(vobs) /w
haptic/other qualities.  Connecting vobspace nodes over the internet is currently
the first priority.

hmaps, the basic units of data for vrtater, are simplified vobs, writable as a
.vrtater file containing one or a set of vobs based on defined type hmapf_t.
hmaps and their founded geometry options are initially written as stock like
basic forms, to then be transformed by modeling functions and drawn by rendering
code.  Their generic nature is supported in all three phases.  hmaps are designed
to provide haptic feedback, vob intersection feedback, and other qualities for
vobs.

Rendering code strives to enhance hmaps, while adding non hmap rendering as well.
Hardware may factor in to technique used.  hmaps will move around in vobspace based
on initial conditions and input, and the renderer may use these hmaps to stoke
non-hmap based drawing and animation. 

vobs may be shared by logging into other nodes with them.  Each hmap authored by
the person running vrtater will have name with high uniqueness that identifies it.
These names will be generated using unique data that is only available to the
author.  This data combined with the appearance of an hmap of name on peer nodes
given cronology, provides a workable authorship mechanism for the 3d works that
hmaps represent.  These hmaps once shared may be copied, however their unique
patterns will have appeared first on the network of vrtater nodes with the name
given, and thus given author will have workable claim of authorship for bragging
rights purposes.

When re-connecting to any node, it may be possible to resume a previous session
there, provided that the called node still has the previous session on hold.
In this way a reputation may be cultivated continuously.

Multiple nodes may connect simultaneously to a given node.  The place where the
interaction occurs is called a node-partial.  One may host multiple
node-partials that are called, or connect to node-partials as a caller.  The
node hosting a node-partial provides an hmap that defines the virtual spacial
bound(nodemap) and optionally any hmaps therein.  When connecting to a
node-partial, the person running vrtater may take hmaps they have along with
them into that partial, those then appearing/shared therein if enough empty
vobspace exists where those would normally appear.

Alternately, a node-orgin, the place where one begins when running vrtater, is
also present once the program is run.  It is similar to a node-partial except
that you are the only one in there, and hmaps therein never appear on other
nodes.  One may create or reuse as many hmaps therein as will fit in memory, and
then optionally take those to node-partials as desired.

The capability for interaction of vobs in a node partial will be as fully as
possible based on dialog and configuration maintained in the node that they
originate out of.  For example, each person running vrtater see's what their
own node presents, for their vobs, and for vobs eminating out of other nodes.
The renderer code tries it's best to present inbound vobs as they describe
themselv's, however, the person running vrtater has the final say.

Dialog may be carried by any given hmap, and may be used for communication
between people running vrtater and interacting in node-partial.  Other
information affecting only hmaps may also be carried therein, for example,
description of how the hmap would like to appear.  A dialog interface, combined
with a node interface will provide access to all selected transforms for hmaps
available, movement stimulus for hmaps, renderer configuration, and more...

Interfacing to system bus IO devices, is soon to commence.  The ip network code,
hashing of session names, rendering features and dialog interface, are all now
calling out for any who would add those, before someone else does less so
excellently.  Maintainer expertise is also in short supply.

For more information on development of vrtater see: @value{DEVELOP}, the
README, provided with the source and listing all references for what is going
on, and the source itself.
@sp 1
@insertcopying
@end ifnottex

@menu
* Invoking vrtater::
* Installing vrtater:: 
* Calls to vectors.c::
* Hmap Selection Buffer::
* Hmap Transforms::
* GNU Free Documentation License::
* Index::
@end menu

@node Invoking vrtater
@chapter Invoking vrtater

@pindex vrtater
@cindex Information on invoking vrtater

@menu
* Synopsis::
* Options::
@end menu

@node Synopsis
@section Synopsis of vrtater command line options

vrtater calls GNU @code{getopt_long()} to parse it's command line options
therefore any single letter short options(example: @code{-f}), have a long
option(example: @code{--find-node}) form.  Optional parameters to command line
arguments that take them, for example @code{-d} with an optional parameter of
@code{0}, needs be given as @code{-d0} or @code{--diag=0}.

@node Options
@section vrtater Options

@table @option

@item --brief

Where applicable output console messages in breif format. (not yet implemented)

@item --diag[=@var{LEVEL}]
@itemx -d[@var{LEVEL}]

Run tug diagnostic, optionally at given LEVEL. (not yet implemented)
see: tug.c for more.

@item --find @var{URL}
@itemx -f @var{URL}

Start @command{vrtater} generating the currently preconfigured node-orgin
vobspace and search the internet for a remote node to connect to once therein.
The required argument is in the form of an node-partial vobspace @file{URL}.
(not yet implemented). Examples may be retreived by running vrtater --partials.
(not yet implemented)

@item --help
@itemx -?

Output vrtater command line usage message.  This will produce the most up to
date version of this section's contents.

@item --informal

If possible, abstract any console message output for readability.
(not yet implemented)

@item --orgin @var{DIR}
@itemx -o @var{DIR}

Start @command{vrtater} generating node-orgin vobspace defined in @file{DIR}.
(not yet implemented)

@item --partial @var{DIR}
@itemx -p @var{DIR}

Start @command{vrtater} generating node-partial vobspace defined in @file{DIR}.
(not yet implemented)

@item --verbose

Where applicable output console messages in verbose format.
(not yet implemented)

@item --version

Output vrtater disclaimers and versions.

@end table

@node Installing vrtater
@chapter Installing vrtater

@pindex vrtater
@cindex Information on installing vrtater

At the moment vrtater is in phase pre-alpha, and has no installation features. You can however download and compile it.  You should have no problems doing that with @command{gcc} if you can already compile programs that include @file{glx.h}.  see: (@value{DEVELOP}) for more info.

@node Calls to vectors.c
@chapter Calls to vectors.c

@pindex vrtater
@cindex Vector calls HOWTO, Reference for calling vectors.c

@multitable @columnfractions .25 .35 .4
@headitem What @tab Code @tab Description
@item for example
@tab @code{vf_t a, b, c;}
@tab of vf_t vector/coord struct
@item note
@tab
@tab all these functions return
@item
@tab
@tab vf_t *result unless specified
@item set
@tab @code{set_vf(&a, x, y, z, m);}
@tab a becomes set to given args
@item ...or...
@tab @code{set_vf(&a, x, y, z, 0);}
@tab then if desired form_mag_vf(&a)
@item copy
@tab @code{cp_vf(&a, &b);}
@tab b becomes a copy of a
@item calcmagnitude
@tab @code{form_mag_vf(&a);}
@tab calculates from (x, y, z, any)
@item
@tab
@tab for new (x, y, z, m')
@item length
@tab @code{length = (&a)->m;}
@tab 'length' (given direction and m)
@item magnifydir
@tab @code{tele_mag_vf(&a, &b, m');}
@tab scales well formed(correct m) in b
@item
@tab
@tab vector(x, y, z, m) to (x', y', z', m')
@item magnifydirz
@tab @code{tele_magz_vf(&a, &b, n');}
@tab b becomes a scaled by [+/-] n
@item
@tab
@tab given (x, y, z, ?) to (x', y', z', m')
@item
@tab
@tab if a is the null vector so is b
@item factor
@tab @code{factor_vf(&a, &b, factor);}
@tab b becomes scaled(as lens)
@item invert
@tab @code{inv_vf(&a, &b);}
@tab b becomes inverted a
@item normalize
@tab @code{norm_vf(&a, &b);}
@tab expects non-zero magnitude or a divide
@item
@tab
@tab by zero error occurs
@item
@tab
@tab b becomes vector normal of a
@item normalizez
@tab @code{normz_vf(&a, &b);}
@tab adjusts/calc's magnitude if zero given
@item
@tab
@tab b becomes vector normal of a
@item
@tab
@tab !!has predictable result _if_ given
@item
@tab
@tab magnitude is not dependant on external
@item
@tab
@tab input.
@item dotproduct
@tab @code{dprod_vf(&a, &b);}
@tab returns dot product result as float
@item crossproduct
@tab @code{cprod_vf(&a, &b, &c);}
@tab c becomes cross product
@item +
@tab @code{sum_vf(&a, &b, &c);}
@tab c becomes sum of a and b
@item summagnitudes
@tab @code{sum_mf(&a, &b);}
@tab returns sum result as float
@item -
@tab @code{dif_vf(&a, &b, &c);}
@tab c becomes difference of a and b
@item difmagnitudes
@tab @code{dif_mf(&a, &b);}
@tab returns difference result as float
@item *
@tab @code{mult_vf(&a, &b, &c);}
@tab c becomes a scaled by b
@item mltmagnitudes
@tab @code{mult_mf(&a, &b);}
@tab returns product result as float
@item /
@tab @code{div_vf(&a, &b, &c);}
@tab c becomes quotient of a over b
@item divmagnitudes
@tab @code{div_mf(&a, &b);}
@tab returns float quotient (&a)->m/(&b)->m
@end multitable

@multitable @columnfractions .25 .35 .4
@headitem Examples @tab Code @tab Description
@item +=
@tab @code{sum_vf(&a, &b, &a);}
@tab note: as above, last vf_t *arg is &result
@item
@tab
@tab save for those functions returning float
@item -=
@tab @code{dif_vf(&a, &b, &a);}
@tab *=, /=, work likewise
@item *2
@tab @code{sum_vf(&a, &a, &a);}
@tab same approach works for all of the above
@item *-1
@tab @code{tele_magz_vf(&a, &b, -1);}
@tab same as inv_vf
@end multitable

For a more extensive example of usage see: src/rotation.c (rotate_vf) that
performs axis-angle rotation using these calls.

note: Using the above functions exclusively on type vf_t data, it seems
logically the case, although full testing has not been completed, that assuming
any magnitude is not already negative, one may insure against this occuring by
always providing only positive scale arguments to tele_mag_vf, factor_vf, and
set_vf.  tele_magz_vf, the only other function here that takes a scale argument
accepts both signed or unsigned.

@node Hmap Selection Buffer
@chapter Hmap Selection Buffer

@pindex vrtater
@cindex Reference for using Hmap Selection Buffer

Reference for using Hmap Selection Buffer

@node Hmap Transforms
@chapter Hmap Transforms

@pindex vrtater
@cindex Documentation of Available Hmap Transforms

Documentation of Available Hmap Transforms

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@node Index
@unnumbered Index

@printindex cp

@bye
